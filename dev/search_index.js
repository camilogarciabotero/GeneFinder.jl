var documenterSearchIndex = {"docs":
[{"location":"iodocs/#Writting-ORFs-into-bioinformatic-formats","page":"Wrtiting ORFs In Files","title":"Writting ORFs into bioinformatic formats","text":"","category":"section"},{"location":"iodocs/","page":"Wrtiting ORFs In Files","title":"Wrtiting ORFs In Files","text":"This package facilitates the creation of FASTA, BED, and GFF files, specifically extracting Open Reading Frame (ORF) information from BioSequence instances, particularly those of type NucleicSeqOrView{A} where A, and then writing the information into the desired format.","category":"page"},{"location":"iodocs/","page":"Wrtiting ORFs In Files","title":"Wrtiting ORFs In Files","text":"Functionality:","category":"page"},{"location":"iodocs/","page":"Wrtiting ORFs In Files","title":"Wrtiting ORFs In Files","text":"The package provides four distinct functions for writing files in different formats:","category":"page"},{"location":"iodocs/","page":"Wrtiting ORFs In Files","title":"Wrtiting ORFs In Files","text":"Function Description\nwrite_orfs_fna Writes nucleotide sequences in FASTA format.\nwrite_orfs_faa Writes amino acid sequences in FASTA format.\nwrite_orfs_bed Outputs information in BED format.\nwrite_orfs_gff Generates files in GFF format.","category":"page"},{"location":"iodocs/","page":"Wrtiting ORFs In Files","title":"Wrtiting ORFs In Files","text":"All these functions support processing both BioSequence instances and external FASTA files. In the case of a BioSequence instace into external files, simply provide the path to the FASTA file using a String to the path. To demonstrate the use of the write_* methods with a BioSequence, consider the following example:","category":"page"},{"location":"iodocs/","page":"Wrtiting ORFs In Files","title":"Wrtiting ORFs In Files","text":"using BioSequences, GeneFinder\n\n# > 180195.SAMN03785337.LFLS01000089 -> finds only 1 gene in Prodigal (from Pyrodigal tests)\nseq = dna\"AACCAGGGCAATATCAGTACCGCGGGCAATGCAACCCTGACTGCCGGCGGTAACCTGAACAGCACTGGCAATCTGACTGTGGGCGGTGTTACCAACGGCACTGCTACTACTGGCAACATCGCACTGACCGGTAACAATGCGCTGAGCGGTCCGGTCAATCTGAATGCGTCGAATGGCACGGTGACCTTGAACACGACCGGCAATACCACGCTCGGTAACGTGACGGCACAAGGCAATGTGACGACCAATGTGTCCAACGGCAGTCTGACGGTTACCGGCAATACGACAGGTGCCAACACCAACCTCAGTGCCAGCGGCAACCTGACCGTGGGTAACCAGGGCAATATCAGTACCGCAGGCAATGCAACCCTGACGGCCGGCGACAACCTGACGAGCACTGGCAATCTGACTGTGGGCGGCGTCACCAACGGCACGGCCACCACCGGCAACATCGCGCTGACCGGTAACAATGCACTGGCTGGTCCTGTCAATCTGAACGCGCCGAACGGCACCGTGACCCTGAACACAACCGGCAATACCACGCTGGGTAATGTCACCGCACAAGGCAATGTGACGACTAATGTGTCCAACGGCAGCCTGACAGTCGCTGGCAATACCACAGGTGCCAACACCAACCTGAGTGCCAGCGGCAATCTGACCGTGGGCAACCAGGGCAATATCAGTACCGCGGGCAATGCAACCCTGACTGCCGGCGGTAACCTGAGC\"","category":"page"},{"location":"iodocs/","page":"Wrtiting ORFs In Files","title":"Wrtiting ORFs In Files","text":"Once a BioSequence object has been instantiated, the write_orfs_fna function proves useful for generating a FASTA file containing the nucleotide sequences of the ORFs. Notably, the write_orfs* methods support either an IOStream or an IOBuffer as an output argument, allowing flexibility in directing the output either to a file or a buffer. In the following example, we demonstrate writing the output directly to a file.","category":"page"},{"location":"iodocs/","page":"Wrtiting ORFs In Files","title":"Wrtiting ORFs In Files","text":"outfile = \"LFLS01000089.fna\"\n\nopen(outfile, \"w\") do io\n    write_orfs_fna(seq, io, NaiveFinder())\nend","category":"page"},{"location":"iodocs/","page":"Wrtiting ORFs In Files","title":"Wrtiting ORFs In Files","text":"cat LFLS01000089.fna\n\n>seq id=01 start=29 stop=40 strand=+ frame=2 score=0.0\nATGCAACCCTGA\n>seq id=02 start=137 stop=145 strand=+ frame=2 score=0.0\nATGCGCTGA\n>seq id=03 start=164 stop=184 strand=+ frame=2 score=0.0\nATGCGTCGAATGGCACGGTGA\n>seq id=04 start=173 stop=184 strand=+ frame=2 score=0.0\nATGGCACGGTGA\n>seq id=05 start=236 stop=241 strand=+ frame=2 score=0.0\nATGTGA\n>seq id=06 start=248 stop=268 strand=+ frame=2 score=0.0\nATGTGTCCAACGGCAGTCTGA\n>seq id=07 start=362 stop=373 strand=+ frame=2 score=0.0\nATGCAACCCTGA\n>seq id=08 start=470 stop=496 strand=+ frame=2 score=0.0\nATGCACTGGCTGGTCCTGTCAATCTGA\n>seq id=09 start=551 stop=574 strand=+ frame=2 score=0.0\nATGTCACCGCACAAGGCAATGTGA\n>seq id=10 start=569 stop=574 strand=+ frame=2 score=0.0\nATGTGA\n>seq id=11 start=581 stop=601 strand=+ frame=2 score=0.0\nATGTGTCCAACGGCAGCCTGA\n>seq id=12 start=695 stop=706 strand=+ frame=2 score=0.0\nATGCAACCCTGA","category":"page"},{"location":"iodocs/#Combining-FASTX-for-reading-and-writing-fastas","page":"Wrtiting ORFs In Files","title":"Combining FASTX for reading and writing fastas","text":"","category":"section"},{"location":"iodocs/","page":"Wrtiting ORFs In Files","title":"Wrtiting ORFs In Files","text":"We can now combine the FASTX package with the function write_orfs_faa to write a FASTA file with the protein sequences of the translated ORFs obtained from an external FASTA file. ","category":"page"},{"location":"iodocs/","page":"Wrtiting ORFs In Files","title":"Wrtiting ORFs In Files","text":"infile = \"test/data/NC_001884.fasta\"\noutfile = \"test/data/NC_001884-orfs.faa\"\n\nopen(inputfile) do io\n    write_orfs_faa(infile, outfile, NaiveFinder())\nend","category":"page"},{"location":"iodocs/","page":"Wrtiting ORFs In Files","title":"Wrtiting ORFs In Files","text":"head test/data/NC_001884-orfs.faa\n\n>ORF0001 id=0001 start=41 stop=145 strand=- frame=2\nMTQKRKGPIPAQFEITPILRFNFIFDLTATNSFH*\n>ORF0002 id=0002 start=41 stop=172 strand=- frame=2\nMVLKDVIVNMTQKRKGPIPAQFEITPILRFNFIFDLTATNSFH*\n>ORF0003 id=0003 start=41 stop=454 strand=- frame=2\nMSEHLSQKEKELKNKENFIFDKYESGIYSDELFLKRKAALDEEFKELQNAKNELNGLQDTQSEIDSNTVRNNINKIIDQYHIESSSEKKNELLRMVLKDVIVNMTQKRKGPIPAQFEITPILRFNFIFDL\nTATNSFH*\n>ORF0004 id=0004 start=41 stop=472 strand=- frame=2\nMKTKKQMSEHLSQKEKELKNKENFIFDKYESGIYSDELFLKRKAALDEEFKELQNAKNELNGLQDTQSEIDSNTVRNNINKIIDQYHIESSSEKKNELLRMVLKDVIVNMTQKRKGPIPAQFEITPILRF\nNFIFDLTATNSFH*\n>ORF0005 id=0005 start=41 stop=505 strand=- frame=2\nMLSKYEDDNSNMKTKKQMSEHLSQKEKELKNKENFIFDKYESGIYSDELFLKRKAALDEEFKELQNAKNELNGLQDTQSEIDSNTVRNNINKIIDQYHIESSSEKKNELLRMVLKDVIVNMTQKRKGPIP\nAQFEITPILRFNFIFDLTATNSFH*","category":"page"},{"location":"iodocs/","page":"Wrtiting ORFs In Files","title":"Wrtiting ORFs In Files","text":"This could also be done to writting a FASTA file with the nucleotide sequences of the ORFs using the write_orfs_fna function. Similarly for the BED and GFF files using the write_orfs_bed and write_orfs_gff functions respectively.","category":"page"},{"location":"api/","page":"API","title":"API","text":"CurrentModule = GeneFinder\nDocTestSetup = quote\n    using GeneFinder\nend","category":"page"},{"location":"api/#The-Main-ORF-type","page":"API","title":"The Main ORF type","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"The main type of the package is ORF which represents an Open Reading Frame.","category":"page"},{"location":"api/","page":"API","title":"API","text":"Modules = [GeneFinder]\nPages = [\"types.jl\"]","category":"page"},{"location":"api/#Finding-ORFs","page":"API","title":"Finding ORFs","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"The function findorfs is the main function of the package. It is generic method that can handle different gene finding methods. ","category":"page"},{"location":"api/","page":"API","title":"API","text":"Modules = [GeneFinder]\nPages = [\"findorfs.jl\"]","category":"page"},{"location":"api/#GeneFinder.findorfs-Union{Tuple{Union{BioSequences.LongDNA{N}, BioSequences.LongSubSeq{BioSequences.DNAAlphabet{N}}}}, Tuple{F}, Tuple{N}} where {N, F<:GeneFinder.GeneFinderMethod}","page":"API","title":"GeneFinder.findorfs","text":"findorfs(sequence::NucleicSeqOrView{DNAAlphabet{N}}; ::M, kwargs...) where {N, M<:GeneFinderMethod}\n\nThis is the main interface method for finding open reading frames (ORFs) in a DNA sequence.\n\nIt takes the following required arguments:\n\nsequence: The nucleic acid sequence to search for ORFs.\nmethod: The algorithm used to find ORFs. It can be either NaiveFinder(), NaiveFinderScored() or yet other implementations.\n\nKeyword Arguments regardless of the finder method:\n\nalternative_start::Bool: A boolean indicating whether to consider alternative start codons. Default is false.\nminlen::Int: The minimum length of an ORF. Default is 6.\nscheme::Function: The scoring scheme to use for scoring the sequence from the ORF. Default is nothing.\n\nReturns\n\nA vector of ORF objects representing the found ORFs.\n\nExample\n\nsequence = randdnaseq(120)\n\n120nt DNA Sequence:\n GCCGGACAGCGAAGGCTAATAAATGCCCGTGCCAGTATC…TCTGAGTTACTGTACACCCGAAAGACGTTGTACGCATTT\n\nfindorfs(sequence, NaiveFinder())\n\n1-element Vector{ORF}:\n ORF{NaiveFinder}(77:118, '-', 2, 0.0)\n\n\n\n\n\n","category":"method"},{"location":"api/#Finding-ORFs-using-BioRegex-and-scoring","page":"API","title":"Finding ORFs using BioRegex and scoring","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"Modules = [GeneFinder]\nPages = [\"algorithms/naivefinder.jl\"]","category":"page"},{"location":"api/#GeneFinder.NaiveFinder-Union{Tuple{Union{BioSequences.LongDNA{N}, BioSequences.LongSubSeq{BioSequences.DNAAlphabet{N}}}}, Tuple{N}} where N","page":"API","title":"GeneFinder.NaiveFinder","text":"NaiveFinder(sequence::NucleicSeqOrView{DNAAlphabet{N}}; kwargs...) -> Vector{ORF} where {N}\n\nA simple implementation that finds ORFs in a DNA sequence.\n\nThe NaiveFinder method takes a LongSequence{DNAAlphabet{4}} sequence and returns a Vector{ORF} containing the ORFs found in the sequence.      It searches entire regularly expressed CDS, adding each ORF it finds to the vector. The function also searches the reverse complement of the sequence, so it finds ORFs on both strands.         Extending the starting codons with the alternative_start = true will search for ATG, GTG, and TTG.     Some studies have shown that in E. coli (K-12 strain), ATG, GTG and TTG are used 83 %, 14 % and 3 % respectively.\n\nnote: Note\nThis function has neither ORFs scoring scheme by default nor length constraints. Thus it might consider aa\"M*\" a posible encoding protein from the resulting ORFs.\n\nRequired Arguments\n\nsequence::NucleicSeqOrView{DNAAlphabet{N}}: The nucleic acid sequence to search for ORFs.\n\nKeywords Arguments\n\nalternative_start::Bool: If true will pass the extended start codons to search. This will increase 3x the execution time. Default is false.\nminlen::Int64=6:  Length of the allowed ORF. Default value allow aa\"M*\" a posible encoding protein from the resulting ORFs.\nscheme::Function: The scoring scheme to use for scoring the sequence from the ORF. Default is nothing.\n\nnote: Note\nAs the scheme is generally a scoring function that at least requires a sequence, one simple scheme is the log-odds ratio score. This score is a log-odds ratio that compares the probability of the sequence generated by a coding model to the probability of the sequence generated by a non-coding model:S(x) = sum_i=1^L beta_x_ix = sum_i=1 log fraca^mathscrm_1_i-1 x_ia^mathscrm_2_i-1 x_iIf the log-odds ratio exceeds a given threshold (η), the sequence is considered likely to be coding. See lordr for more information about coding creteria.\n\n\n\n\n\n","category":"method"},{"location":"api/#GeneFinder._locationiterator-Union{Tuple{Union{BioSequences.LongDNA{N}, BioSequences.LongSubSeq{BioSequences.DNAAlphabet{N}}}}, Tuple{N}} where N","page":"API","title":"GeneFinder._locationiterator","text":"locationiterator(sequence::NucleicSeqOrView{DNAAlphabet{N}}; alternative_start::Bool=false) where {N}\n\nThis is an iterator function that uses regular expressions to search the entire ORF (instead of start and stop codons) in a LongSequence{DNAAlphabet{4}} sequence.     It uses an anonymous function that will find the first regularly expressed ORF. Then using this anonymous function it creates an iterator that will apply it until there is no other CDS.\n\nnote: Note\nAs a note of the implementation we want to expand on how the ORFs are found:The expression (?:[N]{3})*? serves as the boundary between the start and stop codons. Within this expression, the character class [N]{3} captures exactly three occurrences of any character (representing nucleotides using IUPAC codes). This portion functions as the regular codon matches. Since it is enclosed within a non-capturing group (?:) and followed by *?, it allows for the matching of intermediate codons, but with a preference for the smallest number of repetitions. In summary, the regular expression ATG(?:[N]{3})*?T(AG|AA|GA) identifies patterns that start with \"ATG,\" followed by any number of three-character codons (represented by \"N\" in the IUPAC code), and ends with a stop codon \"TAG,\" \"TAA,\" or \"TGA.\" This pattern is commonly used to identify potential protein-coding regions within genetic sequences.See more about the discussion here\n\n\n\n\n\n","category":"method"},{"location":"api/#Geting-ORFs-sequences","page":"API","title":"Geting ORFs sequences","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"Modules = [GeneFinder]\nPages = [\"getorfs.jl\"]","category":"page"},{"location":"api/#Writing-ORFs-to-files","page":"API","title":"Writing ORFs to files","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"Modules = [GeneFinder]\nPages = [\"io.jl\"]","category":"page"},{"location":"api/#GeneFinder.write_orfs_bed-Union{Tuple{F}, Tuple{N}, Tuple{Union{BioSequences.LongDNA{N}, BioSequences.LongSubSeq{BioSequences.DNAAlphabet{N}}, String}, Union{IOStream, IOBuffer}}} where {N, F<:GeneFinder.GeneFinderMethod}","page":"API","title":"GeneFinder.write_orfs_bed","text":"write_orfs_bed(input::NucleicSeqOrView{DNAAlphabet{N}}, output::Union{IOStream, IOBuffer}, method::M; kwargs...) where {N, M<:GeneFinderMethod}\nwrite_orfs_bed(input::NucleicSeqOrView{DNAAlphabet{N}}, output::String, ::M; kwargs...) where {N, M<:GeneFinderMethod}\nwrite_orfs_bed(input::String, output::Union{IOStream, IOBuffer}, method::M; kwargs...) where {M<:GeneFinderMethod}\nwrite_orfs_bed(input::String, output::String, method::M; kwargs...) where {M<:GeneFinderMethod}\n\nWrite BED data to a file.\n\nArguments\n\ninput::NucleicAcidAlphabet{DNAAlphabet{N}}: The input DNA sequence.\noutput::IO: The otput format, it can be a file (String) or a buffer (IOStream or `IOBuffer)\nmethod::M: The algorithm used to find ORFs. It can be either NaiveFinder() or NaiveFinderScored().\n\nKeywords\n\nalternative_start::Bool=false: If true, alternative start codons will be used when identifying CDSs. Default is false.\nminlen::Int64=6: The minimum length that a CDS must have in order to be included in the output file. Default is 6.\n\n\n\n\n\n","category":"method"},{"location":"api/#GeneFinder.write_orfs_faa-Union{Tuple{F}, Tuple{N}, Tuple{Union{BioSequences.LongDNA{N}, BioSequences.LongSubSeq{BioSequences.DNAAlphabet{N}}, String}, Union{IOStream, IOBuffer}}} where {N, F<:GeneFinder.GeneFinderMethod}","page":"API","title":"GeneFinder.write_orfs_faa","text":"write_orfs_faa(input::NucleicSeqOrView{DNAAlphabet{4}}, output::Union{IOStream, IOBuffer}, method::M; kwargs...) where {N, M<:GeneFinderMethod}\nwrite_orfs_faa(input::NucleicSeqOrView{DNAAlphabet{4}}, output::String, method::M; kwargs...) where {N, M<:GeneFinderMethod}\nwrite_orfs_faa(input::String, output::Union{IOStream, IOBuffer}, method::M; kwargs...) where {M<:GeneFinderMethod}\nwrite_orfs_faa(input::String, output::String, method::M; kwargs...) where {M<:GeneFinderMethod}\n\nWrite the protein sequences encoded by the coding sequences (CDSs) of a given DNA sequence to the specified file.\n\nArguments\n\ninput::NucleicAcidAlphabet{DNAAlphabet{N}}: The input DNA sequence.\noutput::IO: The otput format, it can be a file (String) or a buffer (IOStream or `IOBuffer)\nmethod::M: The algorithm used to find ORFs. It can be either NaiveFinder() or NaiveFinderScored().\n\nKeywords\n\ncode::GeneticCode=BioSequences.standard_genetic_code: The genetic code by which codons will be translated. See BioSequences.ncbi_trans_table for more info. \nalternative_start::Bool=false: If true will pass the extended start codons to search. This will increase 3x the exec. time.\nminlen::Int64=6:  Length of the allowed ORF. Default value allow aa\"M*\" a posible encoding protein from the resulting ORFs.\n\nExamples\n\nfilename = \"output.faa\"\n\nseq = dna\"ATGATGCATGCATGCATGCTAGTAACTAGCTAGCTAGCTAGTAA\"\n\nopen(filename, \"w\") do file\n     write_orfs_faa(seq, file)\nend\n\n\n\n\n\n","category":"method"},{"location":"api/#GeneFinder.write_orfs_fna-Union{Tuple{F}, Tuple{N}, Tuple{Union{BioSequences.LongDNA{N}, BioSequences.LongSubSeq{BioSequences.DNAAlphabet{N}}, String}, Union{IOStream, IOBuffer}}} where {N, F<:GeneFinder.GeneFinderMethod}","page":"API","title":"GeneFinder.write_orfs_fna","text":"write_orfs_fna(input::NucleicSeqOrView{DNAAlphabet{N}}, output::Union{IOStream, IOBuffer}, method::M; kwargs...) where {N, M<:GeneFinderMethod}\nwrite_orfs_fna(input::NucleicSeqOrView{DNAAlphabet{N}}, output::String, method::M; kwargs...) where {N, M<:GeneFinderMethod}\nwrite_orfs_fna(input::String, output::Union{IOStream, IOBuffer}; kwargs...) where {M<:GeneFinderMethod}\nwrite_orfs_fna(input::String, output::String, method::M; kwargs...) where {M<:GeneFinderMethod}\n\nWrite a file containing the coding sequences (CDSs) of a given DNA sequence to the specified file.\n\nArguments\n\ninput::NucleicAcidAlphabet{DNAAlphabet{N}}: The input DNA sequence.\noutput::IO: The otput format, it can be a file (String) or a buffer (IOStream or `IOBuffer)\nmethod::M: The algorithm used to find ORFs. It can be either NaiveFinder() or NaiveFinderScored().\n\nKeywords\n\nalternative_start::Bool=false: If true, alternative start codons will be used when identifying CDSs. Default is false.\nminlen::Int64=6: The minimum length that a CDS must have in order to be included in the output file. Default is 6.\n\nExamples\n\nfilename = \"output.fna\"\n\nseq = dna\"ATGATGCATGCATGCATGCTAGTAACTAGCTAGCTAGCTAGTAA\"\n\nopen(filename, \"w\") do file\n     write_orfs_fna(seq, file, NaiveFinder())\nend\n\n\n\n\n\n","category":"method"},{"location":"api/#GeneFinder.write_orfs_gff-Union{Tuple{F}, Tuple{N}, Tuple{Union{BioSequences.LongDNA{N}, BioSequences.LongSubSeq{BioSequences.DNAAlphabet{N}}, String}, Union{IOStream, IOBuffer}}} where {N, F<:GeneFinder.GeneFinderMethod}","page":"API","title":"GeneFinder.write_orfs_gff","text":"write_orfs_gff(input::NucleicSeqOrView{DNAAlphabet{N}}, output::Union{IOStream, IOBuffer}, method::M; kwargs...) where {N, M<:GeneFinderMethod}\nwrite_orfs_gff(input::NucleicSeqOrView{DNAAlphabet{N}}, output::String, method::M; kwargs...) where {N, M<:GeneFinderMethod}\nwrite_orfs_gff(input::String, output::Union{IOStream, IOBuffer}, method::M; kwargs...)  where {M<:GeneFinderMethod}\nwrite_orfs_gff(input::String, output::String, method::M; kwargs...) where {M<:GeneFinderMethod}\n\nWrite GFF data to a file.\n\nArguments\n\ninput::NucleicAcidAlphabet{DNAAlphabet{N}}: The input DNA sequence.\noutput::IO: The otput format, it can be a file (String) or a buffer (IOStream or `IOBuffer)\nmethod::M: The algorithm used to find ORFs. It can be either NaiveFinder() or NaiveFinderScored().\n\nKeywords\n\ncode::GeneticCode=BioSequences.standard_genetic_code: The genetic code by which codons will be translated. See BioSequences.ncbi_trans_table for more info. \nalternative_start::Bool=false: If true will pass the extended start codons to search. This will increase 3x the exec. time.\nminlen::Int64=6:  Length of the allowed ORF. Default value allow aa\"M*\" a posible encoding protein from the resulting ORFs.\n\n\n\n\n\n","category":"method"},{"location":"simplecodingrule/#Scoring-a-sequence-using-a-Markov-model","page":"A Simple Coding Rule","title":"Scoring a sequence using a Markov model","text":"","category":"section"},{"location":"simplecodingrule/","page":"A Simple Coding Rule","title":"A Simple Coding Rule","text":"A sequence of DNA could be scored using a Markov model of the transition probabilities of a known sequence. This could be done using a log-odds ratio score, which is the logarithm of the ratio of the transition probabilities of the sequence given a model and. The log-odds ratio score is defined as:","category":"page"},{"location":"simplecodingrule/","page":"A Simple Coding Rule","title":"A Simple Coding Rule","text":"beginalign\nS(x) = sum_i=1^L beta_x_ix = sum_i=1 log fraca^mathscrm_1_i-1 x_ia^mathscrm_2_i-1 x_i\nendalign","category":"page"},{"location":"simplecodingrule/","page":"A Simple Coding Rule","title":"A Simple Coding Rule","text":"Where the a^mathscrm_1_i-1 x_i is the transition probability of the first model (in this case the calculated for the given sequence) from the state x_i-1 to the state x_i and a^mathscrm_2_i-1 x_i is the transition probability of the second model from the state x_i-1 to the state x_i. The score is the sum of the log-odds ratio of the transition probabilities of the sequence given the two models.","category":"page"},{"location":"simplecodingrule/","page":"A Simple Coding Rule","title":"A Simple Coding Rule","text":"In the current implementation the second model is a CDS transition probability model of E. coli. This classification score is implemented in the naivescorefinder method. This method will return ORFs with the associated score of the sequence given the CDS model of E. coli.","category":"page"},{"location":"simplecodingrule/","page":"A Simple Coding Rule","title":"A Simple Coding Rule","text":"using GeneFinder, BioSequences\n\nseq = dna\"TTCGTCAGTCGTTCTGTTTCATTCAATACGATAGTAATGTATTTTTCGTGCATTTCCGGTGGAATCGTGCCGTCCAGCATAGCCTCCAGATATCCCCTTATAGAGGTCAGAGGGGAACGGAAATCGTGGGATACATTGGCTACAAACTTTTTCTGATCATCCTCGGAACGGGCAATTTCGCTTGCCATATAATTCAGACAGGAAGCCAGATAACCGATTTCATCCTCACTATCGACCTGAAATTCATAATGCATATTACCGGCAGCATACTGCTCTGTGGCATGAGTGATCTTCCTCAGAGGAATATATACGATCTCAGTGAAAAAGATCAGAATGATCAGGGATAGCAGGAACAGGATTGCCAGGGTGATATAGGAAATATTCAGCAGGTTGTTACAGGATTTCTGAATATCATTCATATCAGTATGGATGACTACATAGCCTTTTACCTTGTAGTTGGAGGTAATGGGAGCAAATACAGTAAGTACATCCGAATCAAAATTACCGAAGAAATCACCAACAATGTAATAGGAGCCGCTGGTTACGGTCGAATCAAAATTCTCAATGACAACCACATTCTCCACATCTAAGGGACTATTGGTATCCAGTACCAGTCGTCCGGAGGGATTGATGATGCGAATCTCGGAATTCAGGTAGACCGCCAGGGAGTCCAGCTGCATTTTAACGGTCTCCAAAGTTGTTTCACTGGTGTACAATCCGCCGGCATAGGTTCCGGCGATCAGGGTTGCTTCGGAATAGAGACTTTCTGCCTTTTCCCGGATCAGATGTTCTTTGGTCATATTGGGAACAAAAGTTGTAACAATGATGAAACCAAATACACCAAAAATAAAATATGCGAGTATAAATTTTAGATAAAGTGTTTTTTTCATAACAAATCCTGCTTTTGGTATGACTTAATTACGTACTTCGAATTTATAGCCGATGCCCCAGATGGTGCTGATCTTCCAGTTGGCATGATCCTTGATCTTCTC\"\n\nfindorfs(seq, minlen=75, finder=NaiveFinder)\n\n9-element Vector{ORF{4, NaiveFinder}}:\n ORF{NaiveFinder}(37:156, '+', 1,)\n ORF{NaiveFinder}(194:268, '-', 2)\n ORF{NaiveFinder}(194:283, '-', 2)\n ORF{NaiveFinder}(249:347, '+', 3)\n ORF{NaiveFinder}(426:590, '+', 3)\n ORF{NaiveFinder}(565:657, '+', 1)\n ORF{NaiveFinder}(650:727, '-', 2)\n ORF{NaiveFinder}(786:872, '+', 3)\n ORF{NaiveFinder}(887:976, '-', 2)","category":"page"},{"location":"simplecodingrule/#The-*log-odds-ratio*-decision-rule","page":"A Simple Coding Rule","title":"The log-odds ratio decision rule","text":"","category":"section"},{"location":"simplecodingrule/","page":"A Simple Coding Rule","title":"A Simple Coding Rule","text":"The sequence probability given a transition probability model could be used as the source of a sequence classification based on a decision rule to classify whether a sequence correspond to a model or another. Now, imagine we got two DNA sequence transition models, a CDS model and a No-CDS model. The log-odds ratio decision rule could be establish as:","category":"page"},{"location":"simplecodingrule/","page":"A Simple Coding Rule","title":"A Simple Coding Rule","text":"beginalign\nS(X) = log fracP_C(X_1=i_1 ldots X_T=i_T)P_N(X_1=i_1 ldots X_T=i_T)  begincases  eta  Rightarrow textcoding   eta  Rightarrow textnoncoding endcases\nendalign","category":"page"},{"location":"simplecodingrule/","page":"A Simple Coding Rule","title":"A Simple Coding Rule","text":"Where the P_C is the probability of the sequence given a CDS model, P_N is the probability of the sequence given a No-CDS model, the decision rule is finally based on whether the ratio is greater or lesser than a given threshold η of significance level.","category":"page"},{"location":"simplecodingrule/","page":"A Simple Coding Rule","title":"A Simple Coding Rule","text":"In this package we have implemented this rule and call some basic models of CDS and No-CDS of E. coli from Axelson-Fisk (2015) work (implemented in BioMarkovChains.jl package). To check whether a random sequence could be coding based on these decision we use the predicate log_odds_ratio_decision_rule with the ECOLICDS and ECOLINOCDS models:","category":"page"},{"location":"simplecodingrule/","page":"A Simple Coding Rule","title":"A Simple Coding Rule","text":"orfsdna = findorfs(seq, minlen=75, alternative_start=true) .|> sequence\n\n20-element Vector{NucSeq{4, DNAAlphabet{4}}}\n ATGTATTTTTCGTGCATTTCCGGTGGAATCGTGCCGTCC…CGGAAATCGTGGGATACATTGGCTACAAACTTTTTCTGA\n GTGCATTTCCGGTGGAATCGTGCCGTCCAGCATAGCCTC…TACGATCTCAGTGAAAAAGATCAGAATGATCAGGGATAG\n GTGCCGTCCAGCATAGCCTCCAGATATCCCCTTATAGAG…CGGAAATCGTGGGATACATTGGCTACAAACTTTTTCTGA\n GTGGGATACATTGGCTACAAACTTTTTCTGATCATCCTC…TACGATCTCAGTGAAAAAGATCAGAATGATCAGGGATAG\n TTGCCATATAATTCAGACAGGAAGCCAGATAACCGATTT…GCATATTACCGGCAGCATACTGCTCTGTGGCATGAGTGA\n ATGCTGCCGGTAATATGCATTATGAATTTCAGGTCGATAGTGAGGATGAAATCGGTTATCTGGCTTCCTGTCTGA\n ATGCCACAGAGCAGTATGCTGCCGGTAATATGCATTATG…ATAGTGAGGATGAAATCGGTTATCTGGCTTCCTGTCTGA\n ATGCATATTACCGGCAGCATACTGCTCTGTGGCATGAGT…TACGATCTCAGTGAAAAAGATCAGAATGATCAGGGATAG\n GTGATCTTCCTCAGAGGAATATATACGATCTCAGTGAAA…ATCAGGGATAGCAGGAACAGGATTGCCAGGGTGATATAG\n ATGGATGACTACATAGCCTTTTACCTTGTAGTTGGAGGT…ATCAAAATTCTCAATGACAACCACATTCTCCACATCTAA\n TTGGTGATTTCTTCGGTAATTTTGATTCGGATGTACTTACTGTATTTGCTCCCATTACCTCCAACTACAAGGTAA\n TTGTTGGTGATTTCTTCGGTAATTTTGATTCGGATGTACTTACTGTATTTGCTCCCATTACCTCCAACTACAAGGTAA\n ATGACAACCACATTCTCCACATCTAAGGGACTATTGGTA…CCGGAGGGATTGATGATGCGAATCTCGGAATTCAGGTAG\n ATGCCGGCGGATTGTACACCAGTGAAACAACTTTGGAGACCGTTAAAATGCAGCTGGACTCCCTGGCGGTCTACCTGA\n TTGTTTCACTGGTGTACAATCCGCCGGCATAGGTTCCGG…TCAGATGTTCTTTGGTCATATTGGGAACAAAAGTTGTAA\n TTGCTTCGGAATAGAGACTTTCTGCCTTTTCCCGGATCAGATGTTCTTTGGTCATATTGGGAACAAAAGTTGTAA\n ATGTTCTTTGGTCATATTGGGAACAAAAGTTGTAACAAT…AAATACACCAAAAATAAAATATGCGAGTATAAATTTTAG\n TTGGTCATATTGGGAACAAAAGTTGTAACAATGATGAAA…ACACCAAAAATAAAATATGCGAGTATAAATTTTAGATAA\n TTGGGAACAAAAGTTGTAACAATGATGAAACCAAATACACCAAAAATAAAATATGCGAGTATAAATTTTAGATAA\n ATGCCAACTGGAAGATCAGCACCATCTGGGGCATCGGCT…TACGTAATTAAGTCATACCAAAAGCAGGATTTGTTATGA\n","category":"page"},{"location":"simplecodingrule/","page":"A Simple Coding Rule","title":"A Simple Coding Rule","text":"Now, we can score the sequences using the log-odds ratio score in the same line:","category":"page"},{"location":"simplecodingrule/","page":"A Simple Coding Rule","title":"A Simple Coding Rule","text":"orfsfeat = findorfs(seq, minlen=75, alternative_start=true, scheme=lors) .|> features\n\n20-element Vector{@NamedTuple{score::Float64}}:\n (score = -2.5146325834372343,)\n (score = -4.857592765476053,)\n (score = -1.9986133020444345,)\n (score = -3.4106894574555824,)\n (score = -1.763485388728319,)\n (score = 0.6825864481251348,)\n (score = 0.21287161698917936,)\n (score = -0.28187825646085224,)\n (score = -1.373474082107631,)\n (score = -4.273794970087796,)\n (score = -2.3961559066784597,)\n (score = -2.3663038090046142,)\n (score = -0.8406863072332524,)\n (score = 1.8013554455006733,)\n (score = -2.0768031699080756,)\n (score = -1.734088708668584,)\n (score = -2.9820908143871194,)\n (score = -3.072550585883162,)\n (score = -2.712493281013948,)\n (score = -2.0453354284951786,)","category":"page"},{"location":"simplecodingrule/","page":"A Simple Coding Rule","title":"A Simple Coding Rule","text":"Now the question is which of those sequences can we consider as coding sequences. We can use the iscoding predicate to check whether a sequence is coding or not based on the log-odds ratio decision rule:","category":"page"},{"location":"simplecodingrule/","page":"A Simple Coding Rule","title":"A Simple Coding Rule","text":"iscoding.(orfsdna) # criteria = log_odds_ratio_decision_rule","category":"page"},{"location":"simplecodingrule/","page":"A Simple Coding Rule","title":"A Simple Coding Rule","text":"20-element BitVector:\n 0\n 0\n 0\n 0\n 0\n 1\n 1\n 0\n 0\n 0\n 0\n 0\n 0\n 1\n 0\n 0\n 0\n 0\n 0\n 0","category":"page"},{"location":"simplecodingrule/","page":"A Simple Coding Rule","title":"A Simple Coding Rule","text":"In this case, the sequence has 20 ORFs and only 3 of them are classified as coding sequences. The classification is based on the log-odds ratio decision rule and the transition probability models of E. coli CDS and No-CDS. The log_odds_ratio_decision_rule method will return a boolean vector with the classification of each ORF in the sequence. Now we can simply filter the ORFs that are coding sequences:","category":"page"},{"location":"simplecodingrule/","page":"A Simple Coding Rule","title":"A Simple Coding Rule","text":"orfs = filter(orf -> iscoding(orf), orfsdna)\n\n3-element Vector{NucSeq{4, DNAAlphabet{4}}}\n ATGCTGCCGGTAATATGCATTATGAATTTCAGGTCGATAGTGAGGATGAAATCGGTTATCTGGCTTCCTGTCTGA\n ATGCCACAGAGCAGTATGCTGCCGGTAATATGCATTATG…ATAGTGAGGATGAAATCGGTTATCTGGCTTCCTGTCTGA\n ATGCCGGCGGATTGTACACCAGTGAAACAACTTTGGAGACCGTTAAAATGCAGCTGGACTCCCTGGCGGTCTACCTGA","category":"page"},{"location":"simplecodingrule/","page":"A Simple Coding Rule","title":"A Simple Coding Rule","text":"Or in terms of the ORF object:","category":"page"},{"location":"simplecodingrule/","page":"A Simple Coding Rule","title":"A Simple Coding Rule","text":"orfs = findorfs(seq, minlen=75, finder=NaiveFinder, alternative_start=true) # find ORFs with alternative start as well\norfs[iscoding.(orfsdna)]\n\n3-element Vector{ORF{4, NaiveFinder}}:\n ORF{NaiveFinder}(194:268, '-', 2, -0.026759927376272922)\n ORF{NaiveFinder}(194:283, '-', 2, -0.010354615336667268)\n ORF{NaiveFinder}(650:727, '-', 2, -0.04303976584597201)","category":"page"},{"location":"simplecodingrule/","page":"A Simple Coding Rule","title":"A Simple Coding Rule","text":"Or in a single line using another genome sequence:","category":"page"},{"location":"simplecodingrule/","page":"A Simple Coding Rule","title":"A Simple Coding Rule","text":"\nphi = dna\"GTGTGAGGTTATAACGCCGAAGCGGTAAAAATTTTAATTTTTGCCGCTGAGGGGTTGACCAAGCGAAGCGCGGTAGGTTTTCTGCTTAGGAGTTTAATCATGTTTCAGACTTTTATTTCTCGCCATAATTCAAACTTTTTTTCTGATAAGCTGGTTCTCACTTCTGTTACTCCAGCTTCTTCGGCACCTGTTTTACAGACACCTAAAGCTACATCGTCAACGTTATATTTTGATAGTTTGACGGTTAATGCTGGTAATGGTGGTTTTCTTCATTGCATTCAGATGGATACATCTGTCAACGCCGCTAATCAGGTTGTTTCTGTTGGTGCTGATATTGCTTTTGATGCCGACCCTAAATTTTTTGCCTGTTTGGTTCGCTTTGAGTCTTCTTCGGTTCCGACTACCCTCCCGACTGCCTATGATGTTTATCCTTTGAATGGTCGCCATGATGGTGGTTATTATACCGTCAAGGACTGTGTGACTATTGACGTCCTTCCCCGTACGCCGGGCAATAACGTTTATGTTGGTTTCATGGTTTGGTCTAACTTTACCGCTACTAAATGCCGCGGATTGGTTTCGCTGAATCAGGTTATTAAAGAGATTATTTGTCTCCAGCCACTTAAGTGAGGTGATTTATGTTTGGTGCTATTGCTGGCGGTATTGCTTCTGCTCTTGCTGGTGGCGCCATGTCTAAATTGTTTGGAGGCGGTCAAAAAGCCGCCTCCGGTGGCATTCAAGGTGATGTGCTTGCTACCGATAACAATACTGTAGGCATGGGTGATGCTGGTATTAAATCTGCCATTCAAGGCTCTAATGTTCCTAACCCTGATGAGGCCGCCCCTAGTTTTGTTTCTGGTGCTATGGCTAAAGCTGGTAAAGGACTTCTTGAAGGTACGTTGCAGGCTGGCACTTCTGCCGTTTCTGATAAGTTGCTTGATTTGGTTGGACTTGGTGGCAAGTCTGCCGCTGATAAAGGAAAGGATACTCGTGATTATCTTGCTGCTGCATTTCCTGAGCTTAATGCTTGGGAGCGTGCTGGTGCTGATGCTTCCTCTGCTGGTATGGTTGACGCCGGATTTGAGAATCAAAAAGAGCTTACTAAAATGCAACTGGACAATCAGAAAGAGATTGCCGAGATGCAAAATGAGACTCAAAAAGAGATTGCTGGCATTCAGTCGGCGACTTCACGCCAGAATACGAAAGACCAGGTATATGCACAAAATGAGATGCTTGCTTATCAACAGAAGGAGTCTACTGCTCGCGTTGCGTCTATTATGGAAAACACCAATCTTTCCAAGCAACAGCAGGTTTCCGAGATTATGCGCCAAATGCTTACTCAAGCTCAAACGGCTGGTCAGTATTTTACCAATGACCAAATCAAAGAAATGACTCGCAAGGTTAGTGCTGAGGTTGACTTAGTTCATCAGCAAACGCAGAATCAGCGGTATGGCTCTTCTCATATTGGCGCTACTGCAAAGGATATTTCTAATGTCGTCACTGATGCTGCTTCTGGTGTGGTTGATATTTTTCATGGTATTGATAAAGCTGTTGCCGATACTTGGAACAATTTCTGGAAAGACGGTAAAGCTGATGGTATTGGCTCTAATTTGTCTAGGAAATAACCGTCAGGATTGACACCCTCCCAATTGTATGTTTTCATGCCTCCAAATCTTGGAGGCTTTTTTATGGTTCGTTCTTATTACCCTTCTGAATGTCACGCTGATTATTTTGACTTTGAGCGTATCGAGGCTCTTAAACCTGCTATTGAGGCTTGTGGCATTTCTACTCTTTCTCAATCCCCAATGCTTGGCTTCCATAAGCAGATGGATAACCGCATCAAGCTCTTGGAAGAGATTCTGTCTTTTCGTATGCAGGGCGTTGAGTTCGATAATGGTGATATGTATGTTGACGGCCATAAGGCTGCTTCTGACGTTCGTGATGAGTTTGTATCTGTTACTGAGAAGTTAATGGATGAATTGGCACAATGCTACAATGTGCTCCCCCAACTTGATATTAATAACACTATAGACCACCGCCCCGAAGGGGACGAAAAATGGTTTTTAGAGAACGAGAAGACGGTTACGCAGTTTTGCCGCAAGCTGGCTGCTGAACGCCCTCTTAAGGATATTCGCGATGAGTATAATTACCCCAAAAAGAAAGGTATTAAGGATGAGTGTTCAAGATTGCTGGAGGCCTCCACTATGAAATCGCGTAGAGGCTTTGCTATTCAGCGTTTGATGAATGCAATGCGACAGGCTCATGCTGATGGTTGGTTTATCGTTTTTGACACTCTCACGTTGGCTGACGACCGATTAGAGGCGTTTTATGATAATCCCAATGCTTTGCGTGACTATTTTCGTGATATTGGTCGTATGGTTCTTGCTGCCGAGGGTCGCAAGGCTAATGATTCACACGCCGACTGCTATCAGTATTTTTGTGTGCCTGAGTATGGTACAGCTAATGGCCGTCTTCATTTCCATGCGGTGCACTTTATGCGGACACTTCCTACAGGTAGCGTTGACCCTAATTTTGGTCGTCGGGTACGCAATCGCCGCCAGTTAAATAGCTTGCAAAATACGTGGCCTTATGGTTACAGTATGCCCATCGCAGTTCGCTACACGCAGGACGCTTTTTCACGTTCTGGTTGGTTGTGGCCTGTTGATGCTAAAGGTGAGCCGCTTAAAGCTACCAGTTATATGGCTGTTGGTTTCTATGTGGCTAAATACGTTAACAAAAAGTCAGATATGGACCTTGCTGCTAAAGGTCTAGGAGCTAAAGAATGGAACAACTCACTAAAAACCAAGCTGTCGCTACTTCCCAAGAAGCTGTTCAGAATCAGAATGAGCCGCAACTTCGGGATGAAAATGCTCACAATGACAAATCTGTCCACGGAGTGCTTAATCCAACTTACCAAGCTGGGTTACGACGCGACGCCGTTCAACCAGATATTGAAGCAGAACGCAAAAAGAGAGATGAGATTGAGGCTGGGAAAAGTTACTGTAGCCGACGTTTTGGCGGCGCAACCTGTGACGACAAATCTGCTCAAATTTATGCGCGCTTCGATAAAAATGATTGGCGTATCCAACCTGCAGAGTTTTATCGCTTCCATGACGCAGAAGTTAACACTTTCGGATATTTCTGATGAGTCGAAAAATTATCTTGATAAAGCAGGAATTACTACTGCTTGTTTACGAATTAAATCGAAGTGGACTGCTGGCGGAAAATGAGAAAATTCGACCTATCCTTGCGCAGCTCGAGAAGCTCTTACTTTGCGACCTTTCGCCATCAACTAACGATTCTGTCAAAAACTGACGCGTTGGATGAGGAGAAGTGGCTTAATATGCTTGGCACGTTCGTCAAGGACTGGTTTAGATATGAGTCACATTTTGTTCATGGTAGAGATTCTCTTGTTGACATTTTAAAAGAGCGTGGATTACTATCTGAGTCCGATGCTGTTCAACCACTAATAGGTAAGAAATCATGAGTCAAGTTACTGAACAATCCGTACGTTTCCAGACCGCTTTGGCCTCTATTAAGCTCATTCAGGCTTCTGCCGTTTTGGATTTAACCGAAGATGATTTCGATTTTCTGACGAGTAACAAAGTTTGGATTGCTACTGACCGCTCTCGTGCTCGTCGCTGCGTTGAGGCTTGCGTTTATGGTACGCTGGACTTTGTGGGATACCCTCGCTTTCCTGCTCCTGTTGAGTTTATTGCTGCCGTCATTGCTTATTATGTTCATCCCGTCAACATTCAAACGGCCTGTCTCATCATGGAAGGCGCTGAATTTACGGAAAACATTATTAATGGCGTCGAGCGTCCGGTTAAAGCCGCTGAATTGTTCGCGTTTACCTTGCGTGTACGCGCAGGAAACACTGACGTTCTTACTGACGCAGAAGAAAACGTGCGTCAAAAATTACGTGCGGAAGGAGTGATGTAATGTCTAAAGGTAAAAAACGTTCTGGCGCTCGCCCTGGTCGTCCGCAGCCGTTGCGAGGTACTAAAGGCAAGCGTAAAGGCGCTCGTCTTTGGTATGTAGGTGGTCAACAATTTTAATTGCAGGGGCTTCGGCCCCTTACTTGAGGATAAATTATGTCTAATATTCAAACTGGCGCCGAGCGTATGCCGCATGACCTTTCCCATCTTGGCTTCCTTGCTGGTCAGATTGGTCGTCTTATTACCATTTCAACTACTCCGGTTATCGCTGGCGACTCCTTCGAGATGGACGCCGTTGGCGCTCTCCGTCTTTCTCCATTGCGTCGTGGCCTTGCTATTGACTCTACTGTAGACATTTTTACTTTTTATGTCCCTCATCGTCACGTTTATGGTGAACAGTGGATTAAGTTCATGAAGGATGGTGTTAATGCCACTCCTCTCCCGACTGTTAACACTACTGGTTATATTGACCATGCCGCTTTTCTTGGCACGATTAACCCTGATACCAATAAAATCCCTAAGCATTTGTTTCAGGGTTATTTGAATATCTATAACAACTATTTTAAAGCGCCGTGGATGCCTGACCGTACCGAGGCTAACCCTAATGAGCTTAATCAAGATGATGCTCGTTATGGTTTCCGTTGCTGCCATCTCAAAAACATTTGGACTGCTCCGCTTCCTCCTGAGACTGAGCTTTCTCGCCAAATGACGACTTCTACCACATCTATTGACATTATGGGTCTGCAAGCTGCTTATGCTAATTTGCATACTGACCAAGAACGTGATTACTTCATGCAGCGTTACCATGATGTTATTTCTTCATTTGGAGGTAAAACCTCTTATGACGCTGACAACCGTCCTTTACTTGTCATGCGCTCTAATCTCTGGGCATCTGGCTATGATGTTGATGGAACTGACCAAACGTCGTTAGGCCAGTTTTCTGGTCGTGTTCAACAGACCTATAAACATTCTGTGCCGCGTTTCTTTGTTCCTGAGCATGGCACTATGTTTACTCTTGCGCTTGTTCGTTTTCCGCCTACTGCGACTAAAGAGATTCAGTACCTTAACGCTAAAGGTGCTTTGACTTATACCGATATTGCTGGCGACCCTGTTTTGTATGGCAACTTGCCGCCGCGTGAAATTTCTATGAAGGATGTTTTCCGTTCTGGTGATTCGTCTAAGAAGTTTAAGATTGCTGAGGGTCAGTGGTATCGTTATGCGCCTTCGTATGTTTCTCCTGCTTATCACCTTCTTGAAGGCTTCCCATTCATTCAGGAACCGCCTTCTGGTGATTTGCAAGAACGCGTACTTATTCGCCACCATGATTATGACCAGTGTTTCCAGTCCGTTCAGTTGTTGCAGTGGAATAGTCAGGTTAAATTTAATGTGACCGTTTATCGCAATCTGCCGACCACTCGCGATTCAATCATGACTTCGTGATAAAAGATTGA\"\n\nfilter(x -> iscoding(sequence(x), η=1e-10) && length(x) > 100, findorfs(phi))\n\n34-element Vector{ORF{4, NaiveFinder}}:\n ORF{NaiveFinder}(636:1622, '+', 3)\n ORF{NaiveFinder}(687:1622, '+', 3)\n ORF{NaiveFinder}(774:1622, '+', 3)\n ORF{NaiveFinder}(781:1389, '+', 1)\n ORF{NaiveFinder}(814:1389, '+', 1)\n ORF{NaiveFinder}(829:1389, '+', 1)\n ORF{NaiveFinder}(861:1622, '+', 3)\n ORF{NaiveFinder}(1021:1389, '+', 1)\n ORF{NaiveFinder}(1386:1622, '+', 3)\n ORF{NaiveFinder}(1447:1635, '+', 1)\n ORF{NaiveFinder}(1489:1635, '+', 1)\n ORF{NaiveFinder}(1501:1635, '+', 1)\n ORF{NaiveFinder}(1531:1635, '+', 1)\n ORF{NaiveFinder}(2697:3227, '+', 3)\n ORF{NaiveFinder}(2745:3227, '+', 3)\n ⋮\n ORF{NaiveFinder}(2874:3227, '+', 3)\n ORF{NaiveFinder}(2973:3227, '+', 3)\n ORF{NaiveFinder}(3108:3227, '+', 3)\n ORF{NaiveFinder}(3142:3312, '+', 1)\n ORF{NaiveFinder}(3481:3939, '+', 1)\n ORF{NaiveFinder}(3659:3934, '+', 2)\n ORF{NaiveFinder}(3734:3934, '+', 2)\n ORF{NaiveFinder}(3772:3939, '+', 1)\n ORF{NaiveFinder}(3806:3934, '+', 2)\n ORF{NaiveFinder}(4129:4287, '+', 1)\n ORF{NaiveFinder}(4160:4291, '-', 2)\n ORF{NaiveFinder}(4540:4644, '+', 1)\n ORF{NaiveFinder}(4690:4866, '+', 1)\n ORF{NaiveFinder}(4741:4866, '+', 1)\n ORF{NaiveFinder}(4744:4866, '+', 1)","category":"page"},{"location":"naivefinder/#The-ORF-type","page":"Finding ORFs","title":"The ORF type","text":"","category":"section"},{"location":"naivefinder/","page":"Finding ORFs","title":"Finding ORFs","text":"For convenience, the ORF type is more stringent in preventing the creation of incompatible instances. As a result, attempting to create an instance with incompatible parameters will result in an error. For instance, the following code snippet will trigger an error:","category":"page"},{"location":"naivefinder/","page":"Finding ORFs","title":"Finding ORFs","text":"ORF{4,NaiveFinder}(1:10, '+', 4) # Or any F <: GeneFinderMethod\n\nERROR: AssertionError: Invalid frame value. Frame must be 1, 2, or 3.\nStacktrace:\n [1] ORF\n   @ ~/.julia/dev/GeneFinder/src/types.jl:52 [inlined]\n [2] ORF{4, NaiveCollector}(range::UnitRange{Int64}, strand::Char, frame::Int64)\n   @ GeneFinder ~/.julia/dev/GeneFinder/src/types.jl:79\n [3] top-level scope\n   @ REPL[20]:1","category":"page"},{"location":"naivefinder/","page":"Finding ORFs","title":"Finding ORFs","text":"Similar behavior will be encountered when the strand is neither + nor -. This precautionary measure helps prevent the creation of invalid ORFs, ensuring greater stability and enabling the extension of its interface. For example, after creating a specific ORF, users can seamlessly iterate over a sequence of interest and verify whether the ORF is contained within the sequence.","category":"page"},{"location":"naivefinder/","page":"Finding ORFs","title":"Finding ORFs","text":"orf = ORF{4,NaiveFinder}(137:145, '+', 2)\nseq[orf]\n\n9nt DNA Sequence:\nATGCGCTGA","category":"page"},{"location":"naivefinder/","page":"Finding ORFs","title":"Finding ORFs","text":"warning: Warning\nIt is still possible to create an ORF and pass it to a sequence that does not necessarily contain an actual open reading frame. This will be addressed in future versions of the package. But the benefit of having it is that it will retrieve the corresponding subsequence of the sequence in a convinient way (5' to 3') regardless of the strand.","category":"page"},{"location":"naivefinder/#Finding-complete-and-overlapped-ORFs","page":"Finding ORFs","title":"Finding complete and overlapped ORFs","text":"","category":"section"},{"location":"naivefinder/","page":"Finding ORFs","title":"Finding ORFs","text":"The first implemented function is findorfs a very non-restrictive ORF finder function that will catch all ORFs in a dedicated structure. Note that this will catch random ORFs not necesarily genes since it has no ORFs size or overlapping condition contraints. Thus it might consider aa\"M*\" a posible encoding protein from the resulting ORFs.","category":"page"},{"location":"naivefinder/","page":"Finding ORFs","title":"Finding ORFs","text":"using BioSequences, GeneFinder\n\n# > 180195.SAMN03785337.LFLS01000089 -> finds only 1 gene in Prodigal (from Pyrodigal tests)\nseq = dna\"AACCAGGGCAATATCAGTACCGCGGGCAATGCAACCCTGACTGCCGGCGGTAACCTGAACAGCACTGGCAATCTGACTGTGGGCGGTGTTACCAACGGCACTGCTACTACTGGCAACATCGCACTGACCGGTAACAATGCGCTGAGCGGTCCGGTCAATCTGAATGCGTCGAATGGCACGGTGACCTTGAACACGACCGGCAATACCACGCTCGGTAACGTGACGGCACAAGGCAATGTGACGACCAATGTGTCCAACGGCAGTCTGACGGTTACCGGCAATACGACAGGTGCCAACACCAACCTCAGTGCCAGCGGCAACCTGACCGTGGGTAACCAGGGCAATATCAGTACCGCAGGCAATGCAACCCTGACGGCCGGCGACAACCTGACGAGCACTGGCAATCTGACTGTGGGCGGCGTCACCAACGGCACGGCCACCACCGGCAACATCGCGCTGACCGGTAACAATGCACTGGCTGGTCCTGTCAATCTGAACGCGCCGAACGGCACCGTGACCCTGAACACAACCGGCAATACCACGCTGGGTAATGTCACCGCACAAGGCAATGTGACGACTAATGTGTCCAACGGCAGCCTGACAGTCGCTGGCAATACCACAGGTGCCAACACCAACCTGAGTGCCAGCGGCAATCTGACCGTGGGCAACCAGGGCAATATCAGTACCGCGGGCAATGCAACCCTGACTGCCGGCGGTAACCTGAGC\"","category":"page"},{"location":"naivefinder/","page":"Finding ORFs","title":"Finding ORFs","text":"Now lest us find the ORFs","category":"page"},{"location":"naivefinder/","page":"Finding ORFs","title":"Finding ORFs","text":"orfs = findorfs(seq, finder=NaiveFinder)\n\n12-element Vector{ORF}:\n ORF{NaiveFinder}(29:40, '+', 2)\n ORF{NaiveFinder}(137:145, '+', 2)\n ORF{NaiveFinder}(164:184, '+', 2)\n ORF{NaiveFinder}(173:184, '+', 2)\n ORF{NaiveFinder}(236:241, '+', 2)\n ORF{NaiveFinder}(248:268, '+', 2)\n ORF{NaiveFinder}(362:373, '+', 2)\n ORF{NaiveFinder}(470:496, '+', 2)\n ORF{NaiveFinder}(551:574, '+', 2)\n ORF{NaiveFinder}(569:574, '+', 2)\n ORF{NaiveFinder}(581:601, '+', 2)\n ORF{NaiveFinder}(695:706, '+', 2)","category":"page"},{"location":"naivefinder/","page":"Finding ORFs","title":"Finding ORFs","text":"Two other methods where implemented into sequence to get the ORFs in DNA or aminoacid sequences, respectively. They use the findorfs function to first get the ORFs and then get the correspondance array of BioSequence objects.","category":"page"},{"location":"naivefinder/","page":"Finding ORFs","title":"Finding ORFs","text":"sequece.(orfs)\n\n12-element Vector{NucSeq{4, DNAAlphabet{4}}}\n ATGCAACCCTGA\n ATGCGCTGA\n ATGCGTCGAATGGCACGGTGA\n ATGGCACGGTGA\n ATGTGA\n ATGTGTCCAACGGCAGTCTGA\n ATGCAACCCTGA\n ATGCACTGGCTGGTCCTGTCAATCTGA\n ATGTCACCGCACAAGGCAATGTGA\n ATGTGA\n ATGTGTCCAACGGCAGCCTGA\n ATGCAACCCTGA","category":"page"},{"location":"naivefinder/","page":"Finding ORFs","title":"Finding ORFs","text":"transalate.(orfs)\n\n12-element Vector{LongSubSeq{AminoAcidAlphabet}}:\n MQP*\n MR*\n MRRMAR*\n MAR*\n M*\n MCPTAV*\n MQP*\n MHWLVLSI*\n MSPHKAM*\n M*\n MCPTAA*\n MQP*","category":"page"},{"location":"roadmap/#Roadmap","page":"-","title":"Roadmap","text":"","category":"section"},{"location":"roadmap/#Coding-genes-(CDS-ORFs)","page":"-","title":"Coding genes (CDS - ORFs)","text":"","category":"section"},{"location":"roadmap/","page":"-","title":"-","text":"☒ Finding ORFs\n☐ EasyGene\n☐ GLIMMER\n☐ Prodigal - Pyrodigal\n☐ PHANOTATE\n☐ k-mer based gene finders (?)\n☐ Augustus (?)","category":"page"},{"location":"roadmap/#Non-coding-genes-(RNA)","page":"-","title":"Non-coding genes (RNA)","text":"","category":"section"},{"location":"roadmap/","page":"-","title":"-","text":"☐ Infernal\n☐ tRNAscan","category":"page"},{"location":"roadmap/#Other-features","page":"-","title":"Other features","text":"","category":"section"},{"location":"roadmap/","page":"-","title":"-","text":"☐ parallelism SIMD ?\n☐ memory management (?)\n☐ incorporate Ribosime Binding Sites (RBS)\n☐ incorporate Programmed Reading Frame Shifting (PRFS)\n☐ specialized types\n☒ Gene\n☒ ORF\n☒ Codon\n☒ CDS\n☐ EukaryoticGene (?)\n☐ ProkaryoticGene (?)\n☐ Intron\n☐ Exon\n☐ GFF –\\> See other packages\n☐ FASTX –\\> See I/O in other packages","category":"page"},{"location":"roadmap/#Compatibilities","page":"-","title":"Compatibilities","text":"","category":"section"},{"location":"roadmap/","page":"-","title":"-","text":"Must interact with or extend:","category":"page"},{"location":"roadmap/","page":"-","title":"-","text":"GenomicAnnotations.jl\nBioSequences.jl\nSequenceVariation.jl\nGenomicFeatures.jl\nFASTX.jl\nKmers.jl\nGraphs.jl","category":"page"},{"location":"","page":"Home","title":"Home","text":"\n<p align=\"center\">\n  <img src=\"assets/logo.svg\" height=\"150\"><br/>\n  <i>A Gene Finder framework for Julia.</i>\n</p>","category":"page"},{"location":"","page":"Home","title":"Home","text":"\n<div style=\"text-align: center;\">\n\n<a href=\"https://camilogarciabotero.github.io/GeneFinder.jl/dev/\">\n  <img src=\"https://img.shields.io/badge/documentation-online-blue.svg?logo=Julia&logoColor=white\" alt=\"Documentation\">\n</a>\n<a href=\"https://github.com/camilogarciabotero/GeneFinder.jl/releases/latest\">\n  <img src=\"https://img.shields.io/github/release/camilogarciabotero/GeneFinder.jl.svg\" alt=\"Release\">\n</a>\n<a href=\"https://doi.org/10.5281/zenodo.7519184\">\n  <img src=\"https://zenodo.org/badge/DOI/10.5281/zenodo.7519184.svg\" alt=\"DOI\">\n</a>\n<a href=\"https://github.com/camilogarciabotero/GeneFinder.jl/actions/workflows/CI.yml\">\n<br>\n  <img src=\"https://github.com/camilogarciabotero/GeneFinder.jl/actions/workflows/CI.yml/badge.svg\" alt=\"GitHub Actions\">\n</a>\n<a href=\"https://github.com/camilogarciabotero/GeneFinder.jl/blob/main/LICENSE\">\n  <img src=\"https://img.shields.io/badge/license-MIT-green.svg\" alt=\"License\">\n</a>\n<a href=\"https://www.repostatus.org/#wip\">\n  <img src=\"https://www.repostatus.org/badges/latest/wip.svg\" alt=\"Repo Status\">\n</a>\n<a href=\"http://juliapkgstats.com/pkg/GeneFinder\">\n  <img src=\"https://img.shields.io/badge/dynamic/json?url=http%3A%2F%2Fjuliapkgstats.com%2Fapi%2Fv1%2Fmonthly_downloads%2FGeneFinder&query=total_requests&suffix=%2Fmonth&label=Downloads\" alt=\"Downloads\">\n</a>\n<a href=\"https://github.com/JuliaTesting/Aqua.jl\">\n  <img src=\"https://raw.githubusercontent.com/JuliaTesting/Aqua.jl/master/badge.svg\" alt=\"Aqua QA\">\n</a>\n\n</div>\n","category":"page"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"#Overview","page":"Home","title":"Overview","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"This is a species-agnostic and algorithm extensible gene finder library for the Julia Language.","category":"page"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"You can install GeneFinder from the julia REPL. Press ] to enter pkg mode, and enter the following:","category":"page"},{"location":"","page":"Home","title":"Home","text":"add GeneFinder\n","category":"page"},{"location":"#Citing","page":"Home","title":"Citing","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"@misc{GeneFinder.jl,\n\tauthor  = {Camilo García},\n\ttitle   = {GeneFinder.jl},\n\turl     = {https://github.com/camilogarciabotero/GeneFinder.jl},\n\tversion = {v0.3.0},\n\tyear    = {2024},\n\tmonth   = {04}\n}","category":"page"}]
}
