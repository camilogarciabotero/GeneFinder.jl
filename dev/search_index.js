var documenterSearchIndex = {"docs":
[{"location":"_index/","page":"-","title":"-","text":"<p align=\"center\"> <img src=\"../assets/logo.svg\" height=\"150\"><br/> <i>A Gene Finder framework for Julia.</i><br/><br/> <a href=\"https://www.repostatus.org/#wip\"> <img src=\"https://www.repostatus.org/badges/latest/wip.svg\"> </a> <a href=\"https://codecov.io/gh/camilogarciabotero/GeneFinder.jl\"> <img src=\"https://img.shields.io/codecov/c/github/camilogarciabotero/GeneFinder.jl?logo=codecov&logoColor=white\"> </a> <a href=\"https://camilogarciabotero.github.io/GeneFinder.jl/dev/\"> <img src=\"https://img.shields.io/badge/documentation-online-blue.svg?logo=Julia&logoColor=white\"> </a> <a href=\"https://travis-ci.com/camilogarciabotero/GeneFinder.jl\"> <img src=\"https://travis-ci.com/camilogarciabotero/GeneFinder.jl.svg?branch=main\"> <a href=\"https://github.com/camilogarciabotero/GeneFinder.jl/blob/main/LICENSE\"> <img src=\"https://img.shields.io/badge/license-MIT-green.svg\"> </a> </p>","category":"page"},{"location":"_index/","page":"-","title":"-","text":"","category":"page"},{"location":"_index/#Overview","page":"-","title":"Overview","text":"","category":"section"},{"location":"_index/","page":"-","title":"-","text":"This is a species-agnostic, algorithm extensible, sequence-anonymous (genome, metagenomes) gene finder library for the Julia Language.","category":"page"},{"location":"_index/","page":"-","title":"-","text":"The main goal is to create a versatile module that enables apply different implemented algorithm to DNA sequences. See, for instance, BioAlignment implementations of different sequence alignment algorithms (local, global, edit-distance).","category":"page"},{"location":"_index/#Installation","page":"-","title":"Installation","text":"","category":"section"},{"location":"_index/","page":"-","title":"-","text":"You can install GeneFinder from the julia REPL. Press ] to enter pkg mode, and enter the following:","category":"page"},{"location":"_index/","page":"-","title":"-","text":"add GeneFinder","category":"page"},{"location":"_index/","page":"-","title":"-","text":"If you are interested in the cutting edge of the development, please check out the master branch to try new features before release.","category":"page"},{"location":"_index/#Algorithms","page":"-","title":"Algorithms","text":"","category":"section"},{"location":"_index/#Coding-genes-(CDS-ORFs)","page":"-","title":"Coding genes (CDS - ORFs)","text":"","category":"section"},{"location":"_index/","page":"-","title":"-","text":"☒ Simple   finder\n☐ EasyGene\n☐ GLIMMER\n☐ Prodigal - Pyrodigal\n☐ PHANOTATE\n☐ k-mer based gene finders (?)\n☐ Augustus (?)","category":"page"},{"location":"_index/#Non-coding-genes-(RNA)","page":"-","title":"Non-coding genes (RNA)","text":"","category":"section"},{"location":"_index/","page":"-","title":"-","text":"☐ Infernal\n☐ tRNAscan","category":"page"},{"location":"_index/#Other-features","page":"-","title":"Other features","text":"","category":"section"},{"location":"_index/","page":"-","title":"-","text":"☐ parallelism SIMD ?\n☐ memory management (?)\n☐ specialized types\n☒ Gene\n☒ ORF\n☒ CDS\n☐ EukaryoticGene (?)\n☐ ProkaryoticGene (?)\n☐ Codon\n☐ Intron\n☐ Exon\n☐ GFF –\\> See other packages\n☐ FASTX –\\> See I/O in other packages","category":"page"},{"location":"_index/#Compatibilities","page":"-","title":"Compatibilities","text":"","category":"section"},{"location":"_index/","page":"-","title":"-","text":"Must interact with or extend:","category":"page"},{"location":"_index/","page":"-","title":"-","text":"GenomicAnnotations.jl\nBioSequences.jl\nSequenceVariation.jl\nGenomicFeatures.jl\nFASTX.jl\nKmers.jl","category":"page"},{"location":"_index/#Contributing","page":"-","title":"Contributing","text":"","category":"section"},{"location":"_index/#Citing","page":"-","title":"Citing","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"CurrentModule = GeneFinder\nDocTestSetup = quote\n    using GeneFinder\nend","category":"page"},{"location":"api/","page":"API","title":"API","text":"","category":"page"},{"location":"api/","page":"API","title":"API","text":"","category":"page"},{"location":"api/","page":"API","title":"API","text":"Modules = [GeneFinder]","category":"page"},{"location":"api/#GeneFinder.GeneFeatures","page":"API","title":"GeneFinder.GeneFeatures","text":"struct GeneFeatures\n    seqname::String\n    start::Int64\n    stop::Int64\n    score::Float64\n    strand::Char\n    frame::'.' \n    attribute::\nend\n\nThis is the main Gene struct, based on the fields that could be found in a GFF3, still needs to be defined correctly,     The idea is correct the frame and attributes that will have something like a possible list (id=Char;name=;locus_tag).     The write and get functions should have a dedicated method for this struct.\n\n\n\n\n\n","category":"type"},{"location":"api/#GeneFinder.ORF","page":"API","title":"GeneFinder.ORF","text":"struct ORF\n    location::UnitRange{Int64}\n    strand::Char\n    frame::Integer\nend\n\nThe ORF struct represents an open reading frame in a DNA sequence. It has two fields: \n\nlocation: which is a UnitRange{Int64} indicating the start and end locations of the ORF in the sequence\nstrand:  is a Char type indicating whether the ORF is on the forward ('+') or reverse ('-') strand of the sequence.\n\n\n\n\n\n","category":"type"},{"location":"api/#GeneFinder.fasta_to_dna-Tuple{AbstractString}","page":"API","title":"GeneFinder.fasta_to_dna","text":"fasta_to_dna(input::String)\n\nConverts a FASTA formatted file (even if it is a multi-fasta) to an array of LongSequence{DNAAlphabet{4}} objects.\n\n\n\n\n\n","category":"method"},{"location":"api/#GeneFinder.findorfs-Union{Tuple{Union{BioSequences.LongNuc{N, <:BioSequences.NucleicAcidAlphabet{N}}, BioSequences.LongSubSeq{<:BioSequences.NucleicAcidAlphabet{N}}}}, Tuple{N}} where N","page":"API","title":"GeneFinder.findorfs","text":"findorfs(sequence::LongSequence{DNAAlphabet{4}}; kwargs...)::Vector{ORF}\nfindorfs(sequence::String; kwargs...)::Vector{ORF}\n\nA simple implementation that finds ORFs in a DNA sequence.\n\nThe findorfs function takes a LongSequence{DNAAlphabet{4}} sequence and returns a Vector{ORF} containing the ORFs found in the sequence.      It searches entire regularly expressed CDS, adding each ORF it finds to the vector. The function also searches the reverse complement of the sequence, so it finds ORFs on both strands.         Extending the starting codons with the alternative_start = true will search for ATG, GTG, and TTG.     Some studies have shown that in E. coli (K-12 strain), ATG, GTG and TTG are used 83 %, 14 % and 3 % respectively.\n\nnote: Note\nThis function has not ORFs scoring scheme. Thus it might consider aa\"M*\" a posible encoding protein from the resulting ORFs.\n\nKeywords\n\nalternative_start::Bool=false: If true will pass the extended start codons to search. This will increase 3x the exec. time.\nmin_len::Int64=6:  Length of the allowed ORF. Default value allow aa\"M*\" a posible encoding protein from the resulting ORFs.\n\n\n\n\n\n","category":"method"},{"location":"api/#GeneFinder.getorfaa-Union{Tuple{Union{BioSequences.LongNuc{N, <:BioSequences.NucleicAcidAlphabet{N}}, BioSequences.LongSubSeq{<:BioSequences.NucleicAcidAlphabet{N}}}}, Tuple{N}} where N","page":"API","title":"GeneFinder.getorfaa","text":"getorfaa(input::LongSequence{DNAAlphabet{4}}; kwargs...)\ngetorfaa(input::String; kwargs...) ## for strings per se\n\nThis function takes a LongSequence{DNAAlphabet{4}} or String sequence and identifies the open reading frames (ORFs) using the findorfs() function. The function then translates each ORF into an amino acid sequence and stores it in a Vector{LongSubSeq{AminoAcidAlphabet}}.\n\nArguments\n\ninput: The input sequence as a LongSequence{DNAAlphabet{4}} or String.\n\nKeyword Arguments\n\nalternative_start::Bool=false: If set to true, the function considers alternative start codons when searching for ORFs. This increases the execution time by approximately 3x.\nmin_len::Int64=6: The minimum length of the allowed ORF. By default, it allows ORFs that can encode at least one amino acid (e.g., aa\"M*\").\n\n\n\n\n\n","category":"method"},{"location":"api/#GeneFinder.getorfdna-Union{Tuple{Union{BioSequences.LongNuc{N, <:BioSequences.NucleicAcidAlphabet{N}}, BioSequences.LongSubSeq{<:BioSequences.NucleicAcidAlphabet{N}}}}, Tuple{N}} where N","page":"API","title":"GeneFinder.getorfdna","text":"getorfdna(input::LongSequence{DNAAlphabet{4}}, output::String; kwargs...)\ngetorfdna(input::String; kwargs...) ## for strings per se\n\nThis function takes a LongSequence{DNAAlphabet{4}} or String sequence and identifies the open reading frames (ORFs) using the findorfs() function. The function then extracts the DNA sequence of each ORF and stores it in a Vector{LongSubSeq{DNAAlphabet{4}}}.\n\nArguments\n\ninput: The input sequence as a LongSequence{DNAAlphabet{4}} or String.\n\nKeyword Arguments\n\nalternative_start::Bool=false: If set to true, the function considers alternative start codons when searching for ORFs. This increases the execution time by approximately 3x.\nmin_len::Int64=6: The minimum length of the allowed ORF. By default, it allows ORFs that can encode at least one amino acid (e.g., aa\"M*\").\n\n\n\n\n\n","category":"method"},{"location":"api/#GeneFinder.hasprematurestop-Union{Tuple{Union{BioSequences.LongNuc{N, <:BioSequences.NucleicAcidAlphabet{N}}, BioSequences.LongSubSeq{<:BioSequences.NucleicAcidAlphabet{N}}}}, Tuple{N}} where N","page":"API","title":"GeneFinder.hasprematurestop","text":"hasprematurestop(sequence::LongNucOrView{4})::Bool\n\nDetermine whether the sequence of type LongSequence{DNAAlphabet{4}} contains a premature stop codon.\n\nReturns a boolean indicating whether the sequence has more than one stop codon.\n\n\n\n\n\n","category":"method"},{"location":"api/#GeneFinder.locationiterator-Union{Tuple{Union{BioSequences.LongNuc{N, <:BioSequences.NucleicAcidAlphabet{N}}, BioSequences.LongSubSeq{<:BioSequences.NucleicAcidAlphabet{N}}}}, Tuple{N}} where N","page":"API","title":"GeneFinder.locationiterator","text":"locationiterator(sequence::LongSequence{DNAAlphabet{4}}; alternative_start::Bool=false)\n\nThis is an iterator function that uses regular expressions to search the entire ORF (instead of start and stop codons) in a LongSequence{DNAAlphabet{4}} sequence.     It uses an anonymous function that will find the first regularly expressed ORF. Then using this anonymous function it creates an iterator that will apply it until there is no other CDS.\n\nnote: Note\nAs a note of the implementation we want to expand on how the ORFs are found:The expression (?:[N]{3})*? serves as the boundary between the start and stop codons. Within this expression, the character class [N]{3} captures exactly three occurrences of any character (representing nucleotides using IUPAC codes). This portion functions as the regular codon matches. Since it is enclosed within a non-capturing group (?:) and followed by *?, it allows for the matching of intermediate codons, but with a preference for the smallest number of repetitions. In summary, the regular expression ATG(?:[N]{3})*?T(AG|AA|GA) identifies patterns that start with \"ATG,\" followed by any number of three-character codons (represented by \"N\" in the IUPAC code), and ends with a stop codon \"TAG,\" \"TAA,\" or \"TGA.\" This pattern is commonly used to identify potential protein-coding regions within genetic sequences.See more about the discussion here\n\n\n\n\n\n","category":"method"},{"location":"api/#GeneFinder.nucleotidefreqs-Tuple{Union{BioSequences.LongSubSeq{<:BioSequences.NucleicAcidAlphabet{4}}, BioSequences.LongNuc{4, <:BioSequences.NucleicAcidAlphabet{4}}}}","page":"API","title":"GeneFinder.nucleotidefreqs","text":"nucleotidefreqs(sequence::LongSequence{DNAAlphabet{4}}) -> Dict{DNA, Float64}\n\nCalculate the frequency of each nucleotide in a DNA sequence.\n\nArguments\n\nsequence::LongSequence{DNAAlphabet{4}}: A LongSequence{DNAAlphabet{4}} sequence.\n\nReturns\n\nA dictionary with each nucleotide in the sequence as a key, and its frequency as a value.\n\nExample\n\nseq = dna\"CCTCCCGGACCCTGGGCTCGGGAC\"\n\nnucleotidefreqs(seq)\n\nDict{DNA, Float64} with 4 entries:\nDNA_T => 0.125\nDNA_A => 0.0833333\nDNA_G => 0.333333\nDNA_C => 0.458333\n\n\n\n\n\n","category":"method"},{"location":"api/#GeneFinder.write_bed-Tuple{BioSequences.LongSequence{BioSequences.DNAAlphabet{4}}, String}","page":"API","title":"GeneFinder.write_bed","text":"write_bed(input::LongSequence{DNAAlphabet{4}}, output::String; kwargs...)\nwrite_bed(input::String, output::String; kwargs...)\n\nWrite BED data to a file.\n\nKeywords\n\nalternative_start::Bool=false: If true will pass the extended start codons to search. This will increase 3x the exec. time.\nmin_len::Int64=6:  Length of the allowed ORF. Default value allow aa\"M*\" a posible encoding protein from the resulting ORFs.\n\n\n\n\n\n","category":"method"},{"location":"api/#GeneFinder.write_cds-Tuple{BioSequences.LongSequence{BioSequences.DNAAlphabet{4}}, String}","page":"API","title":"GeneFinder.write_cds","text":"write_cds(input::LongSequence{DNAAlphabet{4}}, output::String; kwargs...)\nwrite_cds(input::String, output::String; kwargs...)\n\nWrite a file containing the coding sequences (CDSs) of a given DNA sequence to the specified file.\n\nKeywords\n\nalternative_start: A boolean value indicating whether alternative start codons should be used when identifying CDSs. Default is false.\nmin_len: An integer representing the minimum length that a CDS must have in order to be included in the output file. Default is 6.\n\n\n\n\n\n","category":"method"},{"location":"api/#GeneFinder.write_gff-Tuple{String, String}","page":"API","title":"GeneFinder.write_gff","text":"write_gff(input::LongSequence{DNAAlphabet{4}}, output::String; kwargs...)\nwrite_gff(input::String, output::String; kwargs...)\n\nWrite GFF data to a file.\n\nKeywords\n\nalternative_start::Bool=false: If true will pass the extended start codons to search. This will increase 3x the exec. time.\nmin_len::Int64=6:  Length of the allowed ORF. Default value allow aa\"M*\" a posible encoding protein from the resulting ORFs.\n\n\n\n\n\n","category":"method"},{"location":"api/#GeneFinder.write_proteins-Tuple{BioSequences.LongSequence{BioSequences.DNAAlphabet{4}}, String}","page":"API","title":"GeneFinder.write_proteins","text":"write_proteins(input::LongSequence{DNAAlphabet{4}}, output::String; kwargs...)\n\nWrite the protein sequences encoded by the coding sequences (CDSs) of a given DNA sequence to the specified file.\n\nKeywords\n\ncode::GeneticCode=BioSequences.standard_genetic_code: The genetic code by which codons will be translated. See BioSequences.ncbi_trans_table for more info. \nalternative_start::Bool=false: If true will pass the extended start codons to search. This will increase 3x the exec. time.\nmin_len::Int64=6:  Length of the allowed ORF. Default value allow aa\"M*\" a posible encoding protein from the resulting ORFs.\n\n\n\n\n\n","category":"method"},{"location":"oldindex/","page":"-","title":"-","text":"","category":"page"},{"location":"oldindex/","page":"-","title":"-","text":"engine: knitr cache: true –-","category":"page"},{"location":"oldindex/","page":"-","title":"-","text":"<p align=\"center\">   <img src=\"../assets/logo.svg\" height=\"150\"><br/>   <i>A Gene Finder framework for Julia.</i><br/><br/>   <a href=\"https://www.repostatus.org/#wip\">     <img src=\"https://www.repostatus.org/badges/latest/wip.svg\">   </a>   <a href=\"https://codecov.io/gh/camilogarciabotero/GeneFinder.jl\">     <img src=\"https://img.shields.io/codecov/c/github/camilogarciabotero/GeneFinder.jl?logo=codecov&logoColor=white\">   </a>   <a href=\"https://camilogarciabotero.github.io/GeneFinder.jl/dev/\">     <img src=\"https://img.shields.io/badge/documentation-online-blue.svg?logo=Julia&logoColor=white\">   </a>   <a href=\"https://travis-ci.com/camilogarciabotero/GeneFinder.jl\">     <img src=\"https://travis-ci.com/camilogarciabotero/GeneFinder.jl.svg?branch=main\">   <a href=\"https://github.com/camilogarciabotero/GeneFinder.jl/blob/main/LICENSE\">     <img src=\"https://img.shields.io/badge/license-MIT-green.svg\">   </a> </p>","category":"page"},{"location":"oldindex/","page":"-","title":"-","text":"","category":"page"},{"location":"oldindex/#Overview","page":"-","title":"Overview","text":"","category":"section"},{"location":"oldindex/","page":"-","title":"-","text":"This is a species-agnostic, algorithm extensible, sequence-anonymous (genome, metagenomes) gene finder library for the Julia Language.","category":"page"},{"location":"oldindex/","page":"-","title":"-","text":"The main goal is to create a versatile module that enables apply different implemented algorithm to DNA sequences. See, for instance, BioAlignment implementations of different sequence alignment algorithms (local, global, edit-distance).","category":"page"},{"location":"oldindex/#Installation","page":"-","title":"Installation","text":"","category":"section"},{"location":"oldindex/","page":"-","title":"-","text":"You can install GeneFinder from the julia REPL. Press ] to enter pkg mode, and enter the following:","category":"page"},{"location":"oldindex/","page":"-","title":"-","text":"add GeneFinder","category":"page"},{"location":"oldindex/","page":"-","title":"-","text":"If you are interested in the cutting edge of the development, please check out the master branch to try new features before release.","category":"page"},{"location":"oldindex/#Algorithms","page":"-","title":"Algorithms","text":"","category":"section"},{"location":"oldindex/#Coding-genes-(CDS-ORFs)","page":"-","title":"Coding genes (CDS - ORFs)","text":"","category":"section"},{"location":"oldindex/","page":"-","title":"-","text":"[x] Simple finder\n[ ] EasyGene\n[ ] GLIMMER\n[ ] Prodigal - Pyrodigal\n[ ] PHANOTATE\n[ ] k-mer based gene finders (?)\n[ ] Augustus (?)","category":"page"},{"location":"oldindex/#Non-coding-genes-(RNA)","page":"-","title":"Non-coding genes (RNA)","text":"","category":"section"},{"location":"oldindex/","page":"-","title":"-","text":"[ ] Infernal\n[ ] tRNAscan","category":"page"},{"location":"oldindex/#Other-features","page":"-","title":"Other features","text":"","category":"section"},{"location":"oldindex/","page":"-","title":"-","text":"[ ] parallelism SIMD ?\n[ ] memory management (?)\n[ ] specialized types\n[x] Gene\n[x] ORF\n[x] CDS\n[ ] EukaryoticGene (?)\n[ ] ProkaryoticGene (?)\n[ ] Codon\n[ ] Intron\n[ ] Exon\n[ ] GFF –> See other packages\n[ ] FASTX –> See I/O in other packages","category":"page"},{"location":"oldindex/#Compatibilities","page":"-","title":"Compatibilities","text":"","category":"section"},{"location":"oldindex/","page":"-","title":"-","text":"Must interact with or extend:","category":"page"},{"location":"oldindex/","page":"-","title":"-","text":"GenomicAnnotations.jl\nBioSequences.jl\nSequenceVariation.jl\nGenomicFeatures.jl\nFASTX.jl\nKmers.jl","category":"page"},{"location":"oldindex/#Contributing","page":"-","title":"Contributing","text":"","category":"section"},{"location":"oldindex/#Citing","page":"-","title":"Citing","text":"","category":"section"},{"location":"oldindex/","page":"-","title":"-","text":"Logo: gene analysis by Vector Points from the Noun Project","category":"page"},{"location":"roadmap/#Roadmap","page":"Roadmap","title":"Roadmap","text":"","category":"section"},{"location":"roadmap/#Coding-genes-(CDS-ORFs)","page":"Roadmap","title":"Coding genes (CDS - ORFs)","text":"","category":"section"},{"location":"roadmap/","page":"Roadmap","title":"Roadmap","text":"☒ Finding ORFs\n☐ EasyGene\n☐ GLIMMER\n☐ Prodigal - Pyrodigal\n☐ PHANOTATE\n☐ k-mer based gene finders (?)\n☐ Augustus (?)","category":"page"},{"location":"roadmap/#Non-coding-genes-(RNA)","page":"Roadmap","title":"Non-coding genes (RNA)","text":"","category":"section"},{"location":"roadmap/","page":"Roadmap","title":"Roadmap","text":"☐ Infernal\n☐ tRNAscan","category":"page"},{"location":"roadmap/#Other-features","page":"Roadmap","title":"Other features","text":"","category":"section"},{"location":"roadmap/","page":"Roadmap","title":"Roadmap","text":"☐ parallelism SIMD ?\n☐ memory management (?)\n☐ incorporate Ribosime Binding Sites (RBS)\n☐ incorporate Programmed Reading Frame Shifting (PRFS)\n☐ specialized types\n☒ Gene\n☒ ORF\n☒ Codon\n☒ CDS\n☐ EukaryoticGene (?)\n☐ ProkaryoticGene (?)\n☐ Intron\n☐ Exon\n☐ GFF –\\> See other packages\n☐ FASTX –\\> See I/O in other packages","category":"page"},{"location":"roadmap/#Compatibilities","page":"Roadmap","title":"Compatibilities","text":"","category":"section"},{"location":"roadmap/","page":"Roadmap","title":"Roadmap","text":"Must interact with or extend:","category":"page"},{"location":"roadmap/","page":"Roadmap","title":"Roadmap","text":"GenomicAnnotations.jl\nBioSequences.jl\nSequenceVariation.jl\nGenomicFeatures.jl\nFASTX.jl\nKmers.jl\nGraphs.jl","category":"page"},{"location":"simplefinder/#Finding-complete-and-internal-(overlapped)-ORFs","page":"Finding ORFs","title":"Finding complete and internal (overlapped) ORFs","text":"","category":"section"},{"location":"simplefinder/","page":"Finding ORFs","title":"Finding ORFs","text":"The first implemented function is findorfs a very non-restrictive ORF finder function that will catch all ORFs in a dedicated structure. Note that this will catch random ORFs not necesarily genes since it has no ORFs size or overlapping condition contraints. Thus it might consider aa\"M*\" a posible encoding protein from the resulting ORFs.","category":"page"},{"location":"simplefinder/","page":"Finding ORFs","title":"Finding ORFs","text":"using BioSequences, GeneFinder\n\n# > 180195.SAMN03785337.LFLS01000089 -> finds only 1 gene in Prodigal (from Pyrodigal tests)\nseq = dna\"AACCAGGGCAATATCAGTACCGCGGGCAATGCAACCCTGACTGCCGGCGGTAACCTGAACAGCACTGGCAATCTGACTGTGGGCGGTGTTACCAACGGCACTGCTACTACTGGCAACATCGCACTGACCGGTAACAATGCGCTGAGCGGTCCGGTCAATCTGAATGCGTCGAATGGCACGGTGACCTTGAACACGACCGGCAATACCACGCTCGGTAACGTGACGGCACAAGGCAATGTGACGACCAATGTGTCCAACGGCAGTCTGACGGTTACCGGCAATACGACAGGTGCCAACACCAACCTCAGTGCCAGCGGCAACCTGACCGTGGGTAACCAGGGCAATATCAGTACCGCAGGCAATGCAACCCTGACGGCCGGCGACAACCTGACGAGCACTGGCAATCTGACTGTGGGCGGCGTCACCAACGGCACGGCCACCACCGGCAACATCGCGCTGACCGGTAACAATGCACTGGCTGGTCCTGTCAATCTGAACGCGCCGAACGGCACCGTGACCCTGAACACAACCGGCAATACCACGCTGGGTAATGTCACCGCACAAGGCAATGTGACGACTAATGTGTCCAACGGCAGCCTGACAGTCGCTGGCAATACCACAGGTGCCAACACCAACCTGAGTGCCAGCGGCAATCTGACCGTGGGCAACCAGGGCAATATCAGTACCGCGGGCAATGCAACCCTGACTGCCGGCGGTAACCTGAGC\"","category":"page"},{"location":"simplefinder/","page":"Finding ORFs","title":"Finding ORFs","text":"Now lest us find the ORFs","category":"page"},{"location":"simplefinder/","page":"Finding ORFs","title":"Finding ORFs","text":"findorfs(seq)\n\n12-element Vector{ORF}:\n ORF(29:40, '+', 2)\n ORF(137:145, '+', 2)\n ORF(164:184, '+', 2)\n ORF(173:184, '+', 2)\n ORF(236:241, '+', 2)\n ORF(248:268, '+', 2)\n ORF(362:373, '+', 2)\n ORF(470:496, '+', 2)\n ORF(551:574, '+', 2)\n ORF(569:574, '+', 2)\n ORF(581:601, '+', 2)\n ORF(695:706, '+', 2)","category":"page"},{"location":"simplefinder/","page":"Finding ORFs","title":"Finding ORFs","text":"Two other functions (getorfdna and getorfaa) pass the sequence to findorfs take the ORFs and act as generators of the sequence, so this way the can be collected in the REPL as an standard output or writteen into a file more conviniently using the FASTX IO system:","category":"page"},{"location":"simplefinder/","page":"Finding ORFs","title":"Finding ORFs","text":"getorfdna(seq)\n\n12-element Vector{LongSubSeq{DNAAlphabet{4}}}:\n ATGCAACCCTGA\n ATGCGCTGA\n ATGCGTCGAATGGCACGGTGA\n ATGGCACGGTGA\n ATGTGA\n ATGTGTCCAACGGCAGTCTGA\n ATGCAACCCTGA\n ATGCACTGGCTGGTCCTGTCAATCTGA\n ATGTCACCGCACAAGGCAATGTGA\n ATGTGA\n ATGTGTCCAACGGCAGCCTGA\n ATGCAACCCTGA","category":"page"},{"location":"simplefinder/","page":"Finding ORFs","title":"Finding ORFs","text":"getorfaa(seq)\n\n12-element Vector{LongSubSeq{AminoAcidAlphabet}}:\n MQP*\n MR*\n MRRMAR*\n MAR*\n M*\n MCPTAV*\n MQP*\n MHWLVLSI*\n MSPHKAM*\n M*\n MCPTAA*\n MQP*","category":"page"},{"location":"simplefinder/#Writting-cds,-proteins-fastas,-bed-and-gffs-whether-from-a-LongSeq-or-from-a-external-fasta-file.","page":"Finding ORFs","title":"Writting cds, proteins fastas, bed and gffs whether from a LongSeq or from a external fasta file.","text":"","category":"section"},{"location":"simplefinder/","page":"Finding ORFs","title":"Finding ORFs","text":"write_cds(\"cds.fasta\", seq)","category":"page"},{"location":"simplefinder/","page":"Finding ORFs","title":"Finding ORFs","text":"cat cds.fasta\n\n>location=29:40 strand=+ frame=2\nATGCAACCCTGA\n>location=137:145 strand=+ frame=2\nATGCGCTGA\n>location=164:184 strand=+ frame=2\nATGCGTCGAATGGCACGGTGA\n>location=173:184 strand=+ frame=2\nATGGCACGGTGA\n>location=236:241 strand=+ frame=2\nATGTGA\n>location=248:268 strand=+ frame=2\nATGTGTCCAACGGCAGTCTGA\n>location=362:373 strand=+ frame=2\nATGCAACCCTGA\n>location=470:496 strand=+ frame=2\nATGCACTGGCTGGTCCTGTCAATCTGA\n>location=551:574 strand=+ frame=2\nATGTCACCGCACAAGGCAATGTGA\n>location=569:574 strand=+ frame=2\nATGTGA\n>location=581:601 strand=+ frame=2\nATGTGTCCAACGGCAGCCTGA\n>location=695:706 strand=+ frame=2\nATGCAACCCTGA","category":"page"},{"location":"simplefinder/#Combining-FASTX-for-reading-and-writing-fastas","page":"Finding ORFs","title":"Combining FASTX for reading and writing fastas","text":"","category":"section"},{"location":"simplefinder/","page":"Finding ORFs","title":"Finding ORFs","text":"using FASTX\n\nwrite_proteins(\"test/data/NC_001884.fasta\", \"proteins.fasta\")","category":"page"},{"location":"simplefinder/","page":"Finding ORFs","title":"Finding ORFs","text":"head proteins.fasta\n\n>location=41:145 strand=- frame=2\nMTQKRKGPIPAQFEITPILRFNFIFDLTATNSFH*\n>location=41:172 strand=- frame=2\nMVLKDVIVNMTQKRKGPIPAQFEITPILRFNFIFDLTATNSFH*\n>location=41:454 strand=- frame=2\nMSEHLSQKEKELKNKENFIFDKYESGIYSDELFLKRKAALDEEFKELQNAKNELNGLQDTQSEIDSNTVRNNINKIIDQYHIESSSEKKNELLRMVLKDVIVNMTQKRKGPIPAQFEITPILRFNFIFDLTATNSFH*\n>location=41:472 strand=- frame=2\nMKTKKQMSEHLSQKEKELKNKENFIFDKYESGIYSDELFLKRKAALDEEFKELQNAKNELNGLQDTQSEIDSNTVRNNINKIIDQYHIESSSEKKNELLRMVLKDVIVNMTQKRKGPIPAQFEITPILRFNFIFDLTATNSFH*\n>location=41:505 strand=- frame=2\nMLSKYEDDNSNMKTKKQMSEHLSQKEKELKNKENFIFDKYESGIYSDELFLKRKAALDEEFKELQNAKNELNGLQDTQSEIDSNTVRNNINKIIDQYHIESSSEKKNELLRMVLKDVIVNMTQKRKGPIPAQFEITPILRFNFIFDLTATNSFH*","category":"page"},{"location":"simplefinder/#The-*log-odds-ratio*-decision-rule","page":"Finding ORFs","title":"The log-odds ratio decision rule","text":"","category":"section"},{"location":"simplefinder/","page":"Finding ORFs","title":"Finding ORFs","text":"The sequence probability given a transition probability model (eq. 2) could be used as the source of a sequence classification based on a decision rule to classify whether a sequence correspond to a model or another. Now, imagine we got two DNA sequence transition models, a CDS model and a No-CDS model. The log-odds ratio decision rule could be establish as:","category":"page"},{"location":"simplefinder/","page":"Finding ORFs","title":"Finding ORFs","text":"beginalign\nS(X) = log fracP_C(X_1=i_1 ldots X_T=i_T)P_N(X_1=i_1 ldots X_T=i_T)  begincases  eta  Rightarrow textcoding   eta  Rightarrow textnoncoding endcases\nendalign","category":"page"},{"location":"simplefinder/","page":"Finding ORFs","title":"Finding ORFs","text":"Where the P_C is the probability of the sequence given a CDS model, P_N is the probability of the sequence given a No-CDS model, the decision rule is finally based on whether the ratio is greater or lesser than a given threshold η of significance level.","category":"page"},{"location":"simplefinder/","page":"Finding ORFs","title":"Finding ORFs","text":"In the GeneFinder we have implemented this rule and a couple of basic transition probability models of CDS and No-CDS of E. coli from Axelson-Fisk (2015) work. To check whether a random sequence could be coding based on these decision we use the predicate iscoding with the ECOLICDS and ECOLINOCDS models:","category":"page"},{"location":"simplefinder/","page":"Finding ORFs","title":"Finding ORFs","text":"randseq = getorfdna(randdnaseq(99))[1] # this will retrieved a random coding ORF\n\niscoding(randseq, ECOLICDS, ECOLINOCDS)","category":"page"},{"location":"simplefinder/","page":"Finding ORFs","title":"Finding ORFs","text":"true","category":"page"},{"location":"","page":"Home","title":"Home","text":"\n<p align=\"center\">\n  <img src=\"assets/logo.svg\" height=\"150\"><br/>\n  <i>A Gene Finder framework for Julia.</i>\n</p>","category":"page"},{"location":"","page":"Home","title":"Home","text":"\n<div style=\"text-align: center;\">\n\n<a href=\"https://camilogarciabotero.github.io/GeneFinder.jl/dev/\">\n  <img src=\"https://img.shields.io/badge/documentation-online-blue.svg?logo=Julia&logoColor=white\" alt=\"Documentation\">\n</a>\n<a href=\"https://github.com/camilogarciabotero/GeneFinder.jl/releases/latest\">\n  <img src=\"https://img.shields.io/github/release/camilogarciabotero/GeneFinder.jl.svg\" alt=\"Release\">\n</a>\n<a href=\"https://doi.org/10.5281/zenodo.7519184\">\n  <img src=\"https://zenodo.org/badge/DOI/10.5281/zenodo.7519184.svg\" alt=\"DOI\">\n</a>\n<a href=\"https://github.com/camilogarciabotero/GeneFinder.jl/actions/workflows/CI.yml\">\n<br>\n  <img src=\"https://github.com/camilogarciabotero/GeneFinder.jl/actions/workflows/CI.yml/badge.svg\" alt=\"GitHub Actions\">\n</a>\n<a href=\"https://github.com/camilogarciabotero/GeneFinder.jl/blob/main/LICENSE\">\n  <img src=\"https://img.shields.io/badge/license-MIT-green.svg\" alt=\"License\">\n</a>\n<a href=\"https://www.repostatus.org/#wip\">\n  <img src=\"https://www.repostatus.org/badges/latest/wip.svg\" alt=\"Repo Status\">\n</a>\n<a href=\"https://pkgs.genieframework.com?packages=GeneFinder\">\n  <img src=\"https://shields.io/endpoint?url=https://pkgs.genieframework.com/api/v1/badge/GeneFinder&label=downloads\" alt=\"Downloads\">\n</a>\n\n</div>\n","category":"page"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"#Overview","page":"Home","title":"Overview","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"This is a species-agnostic, algorithm extensible, sequence-anonymous (genome, metagenomes) gene finder library for the Julia Language.","category":"page"},{"location":"","page":"Home","title":"Home","text":"The main goal is to create a versatile module that enables apply different implemented algorithm to DNA sequences.","category":"page"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"You can install GeneFinder from the julia REPL. Press ] to enter pkg mode, and enter the following:","category":"page"},{"location":"","page":"Home","title":"Home","text":"add GeneFinder\n","category":"page"},{"location":"#Citing","page":"Home","title":"Citing","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"@misc{GeneFinder.jl,\n\tauthor  = {Camilo García},\n\ttitle   = {GeneFinder.jl},\n\turl     = {https://github.com/camilogarciabotero/GeneFinder.jl},\n\tversion = {v0.0.23},\n\tyear    = {2022},\n\tmonth   = {11}\n}","category":"page"}]
}
